# 스프링 프레임워크의 역사 🌿

## 1. EJB 시대 🏢
- 1990년대 말부터 2000년대 초반까지 자바 엔터프라이즈 애플리케이션 개발을 위한 표준.
- 복잡하고 무거운 구조로 인해 개발자들이 간단하고 유연한 대안을 모색.

## 2. J2EE의 등장 📚
- 자바 기반의 엔터프라이즈 애플리케이션 개발을 위한 표준 플랫폼.
- EJB를 포함한 다양한 기술 제공.
- 복잡성과 무거운 구조로 인해 비판 받음.

## 3. 스프링 프레임워크의 탄생 🌱
- 2003년 로드 존슨(Rod Johnson)에 의해 소개됨.
- J2EE의 복잡성 해결을 목표로 IoC(제어의 역전), AOP(관점 지향 프로그래밍) 등을 지원.
- 개발자들에게 더 나은 개발 경험 제공.

## 4. 하이버네이트의 등장 💾
- 자바 ORM(Object-Relational Mapping) 라이브러리.
- 복잡한 JDBC 코드 작성 없이 데이터베이스 작업 수행 가능.
- 스프링과 잘 통합되어 널리 사용됨.

## 5. JPA의 도입 📘
- 자바 표준 ORM 인터페이스.
- 하이버네이트 등 ORM 툴과 함께 사용되어 데이터베이스 작업을 표준화된 방식으로 처리.
- Java EE 5부터 표준으로 채택됨.

## 현재의 스프링 🚀
- 마이크로서비스 아키텍처, 클라우드 네이티브 애플리케이션 개발 등 현대적인 개발 요구 사항을 지원.
- 스프링 부트(Spring Boot) 등의 프로젝트를 통해 지속적으로 발전.


# 스프링 생태계 🌿

## 핵심 프로젝트 🛠️
- **스프링 프레임워크** 🌱: 핵심 기능으로는 DI(의존성 주입), AOP(관점 지향 프로그래밍), 이벤트, 기타
- **스프링 부트** 🚀: 스프링 애플리케이션을 쉽고 빠르게 구축할 수 있도록 도와주는 프로젝트

## 웹 프로젝트 🌐
- **스프링 MVC** 📄: 모델-뷰-컨트롤러 아키텍처를 기반으로 하는 웹 프레임워크
- **스프링 WebFlux** ⚡: 비동기, 논블로킹 웹 애플리케이션을 구축하기 위한 프레임워크

## 데이터 접근/통합 프로젝트 💾
- **스프링 데이터** 📊: 데이터 액세스 기술을 추상화하여 일관된 데이터 접근 방식 제공
- **스프링 배치** 🔄: 대량의 데이터 처리 작업을 위한 배치 프로세싱 기능 제공
- **스프링 시큐리티** 🔒: 애플리케이션의 보안을 위한 포괄적인 보안 솔루션
- **스프링 Rest Docs** 📚: RESTful 서비스 문서를 쉽게 작성할 수 있도록 도와주는 프로젝트

## 클라우드 프로젝트 ☁️
- **스프링 클라우드** 🌥️: 마이크로서비스 기반 애플리케이션의 개발, 배포, 운영을 지원하는 툴 제공

## 기타 프로젝트 🧩
- **스프링 통합** 🤝: 엔터프라이즈 통합 패턴을 적용한 애플리케이션 통합
- **스프링 HATEOAS** 🔗: REST API의 HATEOAS 원칙을 지원하는 프로젝트
- **스프링 세션** 🗄️: 세션 관리를 위한 API와 구현체 제공

## 기술 지원 🛠️
- **핵심 기술** 💡: DI 컨테이너, AOP, 이벤트, 기타
- **웹 기술** 🌐: 스프링 MVC, 스프링 WebFlux
- **데이터 접근/통합 기술** 💾: 트랜잭션, JDBC, ORM 지원, XML 지원
- **기술 통합** 🧰: 메시지, 이메일, 웹소켓, 스케줄링
- **테스트** 🧪: 스프링 기반 테스트 지원

## 산업 🏭
- **안전** 🔐: 국방부, 그룹웨어
- **현실에서** 🌟: 스프링 부트를 통해서 스프링 프레임워크의 기능들을 빠르게 사용

# 스프링 부트 🚀

- 스프링을 편리하게 사용할 수 있도록 지원, 최신에는 기술로 사용
- 다양으로 사용할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장하여 별도의 웹 서버를 설치하지 않아도 됨
- 소스를 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관리에 이해 간결한 설정

## 스프링은 뭐야? 🤔

- 스프링이란 다양한 목적에 따라 다르게 사용된다.
    - 스프링 DI 컨테이너 기능 🛠️
    - 스프링 프레임워크 🌱
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 스프링 생태계 🌐

# 스프링의 진짜 핵심 🔑

- 스프링은 자바 언어 기반의 프레임워크 🌿
- 자바 언어의 가장 큰 특징 - 객체 지향 언어 🎓
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크 💪
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크 👍

# 좋은 객체 지향 프로그래밍? 🏛️

## 객체 지향 특징 🎨

- 추상화 🖼️
- 캡슐화 📦
- 상속 👨‍👩‍👧‍👦
- 다형성 🔀


# 객체 지향 프로그래밍 🖥️

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것입니다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있습니다. (협력) 🤝
- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됩니다. 🛠️

## 유연하고, 변경에 용이? 🔄

- 레고 블럭 조립하듯이 🧱
- 키보드, 마우스 갈아 끼우듯이 ⌨️🖱️
- 컴퓨터 부품 갈아 끼우듯이 🖥️
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법 🧩

# 다형성 (Polymorphism) 🎭

## 다형성의 실세계 비유 🌍

- 실세계와 객체 지향을 1:1로 매칭하지는 않지만, 그래도 실세계의 비유로 이해하기에는 좋습니다.
- 역할과 구현으로 세상을 구분합니다. 🚗🎭

## 다형성의 실세계 비유 (예시) 🌟

- 운전자 - 자동차 🚗
- 공연 무대 🎪
- 키보드, 마우스, 세상의 표준 인터페이스들 ⌨️🖱️
- 정렬 알고리즘 🔢
- 할인 정책 로직 💸

## 역할과 구현을 분리 🎭

- 역할(`interface`)과 구현(`class`)을 구분하면, 세상이 단순해지고, 유연해지며 변경도 편리해집니다.
- **장점**:
    - 클라이언트는 대상의 **역할**만 알면 됩니다. 🎬
    - 클라이언트는 구현 대상의 내부 구조를 몰라도 됩니다. 🤷
    - 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않습니다. 🔄
    - 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않습니다. 🆕

- 자바 언어의 **다형성**을 활용하여:
    - **역할** = 인터페이스 📝
    - **구현** = 인터페이스를 구현한 클래스, 구현 객체 🏗️
- 객체를 설계할 때는 역할과 구현을 명확히 분리하고, 객체 설계 시 역할을 먼저 부여한 후 구현 객체를 만들어야 합니다.

## 객체의 협력이라는 관계부터 생각 🤝

- 혼자 있는 객체는 없으며, 모든 객체는 서로 **협력**하는 관계에 있습니다.
- 클라이언트(요청)와 서버(응답) 간의 상호 작용을 통해 프로그램은 운영됩니다.

# 자바 인터페이스의 다형성 🌟

다형성을 활용하여 얻을 수 있는 이점들:

- **오버라이딩을 통한 유연성**: 서로 다른 구현을 가능하게 하는 오버라이딩 🔄
- **오버라이딩으로 기능 확장**: 기존 코드 변경 없이 새 기능 추가 및 확장 📈
- **다형성을 통한 재사용성**: 코드 재사용성 향상 📦
- **인터페이스 구현 클래스 교체 용이성**: 쉽게 교체하며 유지보수 및 확장성 보장 🔧
- **롤 모델로서의 상속과 다형성**: '롤 모델' 클래스로 다양한 상황 적용 가능 🎭

`MemberService` 인터페이스의 구현 예시는 다음과 같습니다:

- `MemoryMemberRepository`와 `JdbcMemberRepository`는 `MemberRepository` 인터페이스를 구현합니다.
- `MemberService`는 `save()`를 호출할 때 구현체가 메모리 기반인지 또는 데이터베이스 기반인지를 몰라도 됩니다.

# 다형성의 본질 💡

- 실행 시점에 인터페이스를 구현한 객체 인스턴스를 유연하게 변경할 수 있습니다.
- 다형성은 객체 사이의 협력 관계에서 시작하여, 클라이언트의 변경 없이 서버의 구현을 변경할 수 있게 합니다.

# 역할과 구현을 분리 (정리) 🧹

- 다형성을 통해 실세계의 역할과 구현의 컨셉을 객체 세상으로 가져올 수 있습니다.
- 유연하고, 변경에 용이한 확장 가능한 설계를 제공합니다.
- 클라이언트에 영향을 주지 않는 변경이 가능합니다.
- 인터페이스 설계의 안정성이 중요합니다.

# 스프링과 객체 지향 🌱

- 스프링은 다형성을 극대화하여 활용할 수 있게 도와줍니다.
- 제어의 역전(IoC)과 의존관계 주입(DI)을 통해 역할과 구현을 편리하게 다룰 수 있습니다.
- 스프링을 사용하면 마치 레고 블럭을 조립하듯이, 또는 공연 무대의 배우를 선택하듯이 구현을 변경할 수 있습니다.

# 좋은 객체 지향 설계의 5가지 원칙 (SOLID) 🏗️

- **SRP**: 단일 책임 원칙(single responsibility principle)
- **OCP**: 개방-폐쇄 원칙 (Open/closed principle)
- **LSP**: 리스코프 치환 원칙 (Liskov substitution principle)
- **ISP**: 인터페이스 분리 원칙 (Interface segregation principle)
- **DIP**: 의존관계 역전 원칙 (Dependency inversion principle)


# SRP 단일 책임 원칙 🎯
## Single responsibility principle

- 한 클래스는 **하나의 책임**만을 가져야 합니다.
- "하나의 책임"이라는 것은 상황에 따라 크기가 다를 수 있습니다. 그러나 중요한 기준은 **변경**입니다.
- 변경 시 **파급 효과**가 적다면, 그 클래스는 단일 책임 원칙을 잘 따르고 있는 것입니다.
- **예시**: UI 변경, 객체의 생성과 사용의 분리는 SRP의 좋은 예입니다.

# OCP 개방-폐쇄 원칙 🔒🔓
## Open/closed principle

- 소프트웨어 요소는 **확장에는 열려** 있으나, **변경에는 닫혀** 있어야 합니다.
- 이는 다소 모순적인 듯 보이지만, **다형성**을 활용하여 해결할 수 있습니다.
- 새로운 기능은 인터페이스를 구현한 **새로운 클래스**를 만들어서 구현함으로써 달성할 수 있습니다.
- 이미 배운 **역할과 구현의 분리**를 다시 생각해봅시다.

## OCP 개방-폐쇄 원칙 (문제점) ❗
- `MemberService` 클라이언트가 구현 클래스를 직접 선택하는 경우:
  ```java
  MemberRepository m = new MemoryMemberRepository(); // 기존 코드
  MemberRepository m = new JdbcMemberRepository(); // 변경 코드

- 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 
- 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다. 
- 이 문제를 어떻게 해결해야 하나? 
- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

# LSP 리스코프 치환 원칙 🔄
## Liskov substitution principle

- 프로그램의 객체는 프로그램의 정확성을 해치지 않으면서 하위 타입의 인스턴스로 교체 가능해야 합니다.
- 다형성을 적절히 활용하기 위해, 하위 클래스는 인터페이스 규약을 모두 준수해야 합니다.
- 컴파일 성공을 넘어서, 실행 중에도 인터페이스의 약속된 행위를 정확히 수행해야 함을 의미합니다.
- **예시**: 자동차 인터페이스의 엑셀러레이터는 '앞으로 가라'는 기능이어야 하며, 이를 '뒤로 가게' 구현한다면 LSP를 위반하는 것입니다.

# ISP 인터페이스 분리 원칙 🧩
## Interface segregation principle

- 클라이언트에 특화된 여러 인터페이스가 단일 범용 인터페이스보다 낫습니다.
- 인터페이스를 분리함으로써, 한 부분의 변경이 다른 클라이언트에 영향을 주지 않도록 할 수 있습니다.
- 이는 인터페이스가 명확해지고, 클래스의 대체 가능성을 높입니다.
- **예시**: 자동차의 인터페이스를 운전 인터페이스와 정비 인터페이스로 분리할 수 있으며, 이는 각각의 클라이언트가 해당 인터페이스만을 사용하도록 합니다.

# DIP 의존관계 역전 원칙 🔗
## Dependency inversion principle

- 프로그래머는 **추상화**에 의존해야 하며, **구체화**에 의존하면 안 됩니다.
- 의존성 주입(Dependency Injection)은 이 원칙을 따르는 한 방법입니다.
- 구현 클래스 대신 인터페이스에 의존함으로써, 유연하게 구현체를 변경할 수 있어야 합니다.
- 하지만, 구현 클래스에 직접 의존하는 경우(예: `new MemoryMemberRepository()`) DIP 원칙에 위배됩니다.
- **문제**: `MemberService`는 인터페이스에 의존하는 것처럼 보이지만, 실제로는 구현 클래스에도 의존합니다. 이는 DIP 원칙을 위반하는 것으로, 의존성 주입을 통해 해결할 수 있습니다.


# 정리 🧾

- 객체 지향의 핵심은 **다형성**입니다.
- 다형성만으로는 부품을 교체하듯이 개발하기 어렵습니다.
- 단순한 다형성을 넘어, 클라이언트 코드의 변경 없이 구현 객체를 유연하게 변경하기 위해선 더 필요합니다.
- OCP(Open/Closed Principle)와 DIP(Dependency Inversion Principle)를 제대로 지키기 위해서는 다형성 이상의 것이 요구됩니다.

# 객체 지향 설계와 스프링 🌱

## 다시 스프링으로 🔙

### 왜 스프링 이야기에서 객체 지향 이야기가 나오는가?

- 스프링은 **다형성**에 더해 **OCP**와 **DIP**를 가능케 하는 기술을 지원합니다:
    - **DI(Dependency Injection)**: 의존관계를 외부에서 주입받는 방식으로, 클라이언트 코드 변경 없이 기능을 확장할 수 있게 합니다.
    - 스프링은 DI 컨테이너를 제공하여, 쉽게 부품을 교체하듯 개발할 수 있도록 합니다.

# 정리 📝

- 설계 시 **역할과 구현을 분리**하는 것이 중요합니다.
- 자동차, 공연 등 실세계의 예를 생각해보세요. 역할(배역)은 정해져 있지만, 그 역할을 수행하는 배우(구현)는 유연하게 변경할 수 있어야 합니다.
- 애플리케이션 설계도 마찬가지로, 유연하게 변경 가능한 배역 설계가 좋은 객체 지향 설계를 나타냅니다.
- 이상적으로는 모든 설계에 **인터페이스를 부여**하는 것이 좋습니다.

## 실무 고민 🤔

- 그러나 인터페이스를 도입하면 **추상화 비용**이 발생합니다.
- 확장할 가능성이 없다면, 처음부터 구체 클래스를 사용하고, 필요할 때 리팩터링을 통해 인터페이스를 도입하는 것도 하나의 방법입니다.




